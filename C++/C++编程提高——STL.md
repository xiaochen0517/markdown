# C++编程提高——STL

## 一、初识STL

### 1.1STL的诞生

- 长久以来，软件界一直希望建立一种可重复利用的东西
- C++的面向对象和泛型编程思想，目的就是复用性的提升
- 大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
- 为了建立数据结构和算法的一套标准，诞生了STL

### 1.2STL基本概念

- STL（Standard Template Library，标准模板库）
- STL从广义上分为：容器（container）算法（algorithm）迭代器（iterator）
- 容器和算法之间通过迭代器进行无缝连接
- STL几乎所有的代码都采用了模板类或者模板函数

### 1.3STL六大组件

STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器

- 容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据
- 算法：各种常用的算法，如sort、find、copy、for_each等
- 迭代器：扮演了容器与算法之间的胶合剂
- 仿函数：行为类似函数，可作为算法的某种策略
- 适配器：用来修饰容器或者仿函数或迭代器
- 空间配置器：负责空间的配置与管理

### 1.4STL中容器、算法、迭代器

**容器：**存放数据的容器

**STL容器**就是将运用最广泛的一些数据结构实现出来

常用的数据结构：数组、链表、树、栈、队列、集合、映射表 等

这些容器分为**序列式容器**和**关联式容器**两种：

- **序列式容器：**强调值的排序，序列式容器中的每个元素均有固定的位置
- **关联式容器：**二叉树结构，各元素之间没有严格的物理上的顺序关系



**算法：**解决问题的办法

有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做**算法（Algorithms**）

算法分为：**质变算法**和**非质变算法**

**质变算法：**是指运算过程中会更改区间内的元素的内容，例如拷贝、替换、删除等

**非质变算法：**是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等



迭代器：容器和算法之间的粘合剂

提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式

每个容器都有自己专属的迭代器

迭代其使用方式非常类似指针，初学阶段我们可以先理解迭代器为指针

迭代器的种类：

| 种类           | 功能                                                     | 支持运算                                |
| -------------- | -------------------------------------------------------- | --------------------------------------- |
| 输入迭代器     | 对数据的只读访问                                         | 只读，支持++、==、!=                    |
| 输出迭代器     | 对数据的只写访问                                         | 只写，支持++                            |
| 前向迭代器     | 读写操作，并能向前推进迭代器                             | 读写，支持++、==、!=                    |
| 双向迭代器     | 读写操作，并能向前和向后操作                             | 读写，支持++、--                        |
| 随机访问迭代器 | 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器

### 1.5容器算法迭代器初识

#### 1.5.1vector存放内置数据类型

容器：`vector`

算法：`for_each`

迭代器：`vector<int>::iterator`

**示例：**

```c++
#include<iostream>
using namespace std;
#include<vector>
#include<algorithm> //标准算法头文件

void myPonit(int val) {
	cout << val << endl;
}

void test51() {
	//创建一个vector容器
	vector<int> v;
	//向容器中添加数据
	for (int i = 1; i <= 10; i++) {
		v.push_back(i * 10);
	}
	//起始迭代器，指向容器中的第一个元素
	vector<int>::iterator begin = v.begin();
	//结束迭代器，指向容器中最后一个元素的下一个位置
	vector<int>::iterator end = v.end();
	//使用起始迭代器和结束迭代器来遍历数组
	while (begin != end) {
		cout << *begin << endl;
		begin++;
	}

	cout << "second method --------------------" << endl;

	//使用for循环遍历数组
	for (vector<int>::iterator b = v.begin(); b < v.end(); b++) {
		cout << *b << endl;
	}

	cout << "third method --------------------" << endl;

	//使用标准算法中的for_each函数
	for_each(v.begin(), v.end(), myPonit);
}

int main() {
	test51();

	system("pause");
	return 0;
}
```

